<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>test</title>
    <script src="/phaser.js"></script>
    <script src="/jquery-3.3.1.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
        .skillsui {
            border: 5px solid black;
        }
        .skillselected {
            border: 5px solid red;
        }
        .skillcasting {
            border: 5px solid blue;
        }
    </style>
</head>
<body>

<script type="text/javascript">
"use strict";

var sceneState;
var game;

window.onload = function() {   
    sceneState = new SceneState();
    game = new Phaser.Game(config);
     
};

/* probably introducing some rounding error here */
let halfWidth = window.innerWidth * window.devicePixelRatio * 0.6 / 2;
let halfHeight = window.innerHeight * window.devicePixelRatio * 0.6 / 2;
var config = {
    type: Phaser.AUTO,
    width: halfWidth * 2,
    height: halfHeight * 2,
    disableContextMenu: true,
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

/* assumes highest supported DPR is 3 */
let imgScale = window.devicePixelRatio / 3;
let unitSize = 128;
let UNIT_SELECTED_IMG = "pink_cursor";

function SceneState() {
    this.units = [];
    this.selected_unit = null;
    this.selected_skill = null;
    this.ui_state = SceneState.prototype.UI_STATE_UNSELECTED;
    this.skill_keys = {};
}
SceneState.prototype.UI_STATE_UNSELECTED = 0;
SceneState.prototype.UI_STATE_SELECTED = 1;
SceneState.prototype.UI_STATE_TARGET_SKILL = 2;
SceneState.prototype.UI_STATE_CASTING = 3;
SceneState.prototype.transition = function(new_state, ctx) {
    switch (new_state) {
        case SceneState.prototype.UI_STATE_UNSELECTED:
            break;
        case SceneState.prototype.UI_STATE_SELECTED:
            if ((this.ui_state === SceneState.prototype.UI_STATE_UNSELECTED) ||
                (this.ui_state === SceneState.prototype.UI_STATE_SELECTED)) {
                $('.skillsui').removeClass('skillselected');
                this.selected_unit = ctx;
            }
            else if (this.ui_state === SceneState.prototype.UI_STATE_CASTING) {
                $('.skillsui').removeClass('skillcasting');
            }
            this.selected_skill = null;
            break;
        case SceneState.prototype.UI_STATE_TARGET_SKILL:
            this.selected_skill = ctx;
            break;
        case SceneState.prototype.UI_STATE_CASTING:
            break;
        default:
            console.log("ERROR: bad state", new_state);
            break;
    }
    console.log("ui_state transitioning from",
                this.ui_state,
                "to",
                new_state);
    this.ui_state = new_state;
}

function PlayerUnit(display_name,
                    char_asset_path,
                    move_target_path,
                    skills) {
    /* html IDs can't have spaces */
    this.name = display_name.replace(/\s/g, '');
    this.display_name = display_name;
    this.char_asset_path = char_asset_path;
    this.move_target_path = move_target_path;
    this.container = null;
    this.sprite = null;
    this.cursor = null;
    this.move_target = null;
    this.has_move_target = false;
    this.move_speed = 5;
    this.skills = skills;
}
PlayerUnit.prototype.move_target_img = function () {
    return this.name + "_movetarget";
}
PlayerUnit.prototype.setMoveTarget = function (pos) {
    this.move_target.x = Math.round(pos.x);
    this.move_target.y = Math.round(pos.y);
    this.move_target.visible = true;
    this.has_move_target = true;
    
    console.log("move to " + this.move_target.x + "," +
                 this.move_target.y);
}
PlayerUnit.prototype.initSkillsUI = function(state) {
    let skill_list_id = "skilllist_" + this.name;
    let skill_list = $('#skilllisttemplate').clone();
    
    skill_list.attr('id', skill_list_id);
    skill_list.css('display', 'none');
    skill_list.empty();
        
    for (let i in this.skills) {
        let skill = this.skills[i];
        let skill_id = skill.dom_id(this);
        let skill_obj = $('#skilltemplate').clone();
        
        skill_obj.attr('id', skill_id);
        skill_obj.attr('value', skill.display_name);
        skill_obj.css('display', 'inline');
        skill_obj.css('visibility', 'visible');
        
        /* XXX: this is a bit janky, fix later */
        skill_obj.click(function() {
            let is_selected = (state.selected_skill === skill);
            skill.selectSkill(this, !is_selected);
        });
        
        skill_list.append(skill_obj);
    }
        
    $('#skills').append(skill_list);
}
PlayerUnit.prototype.showSkillsUI = function() {
    /* TODO: hide the old skill list (by class?) or remove children */
    let skill_list_id = "skilllist_" + this.name;
    
    $('#' + skill_list_id).css('display', 'block');
    $('#' + skill_list_id).css('visibility', 'visible');
    
    /* TODO: do this stuff exactly once */    
    $('#skilltemplate').css('display', 'none');
    $('#skilllisttemplate').css('display', 'none');
    $('#skills').css('visibility', 'visible');    
}

function Skill(display_name,
               preload,
               create,
               select,
               updateCursor,
               finishCasting) {
    /* html IDs can't have spaces */
    this.name = display_name.replace(/\s/g, '');
    this.display_name = display_name;
    
    this.preload = preload;
    this.create = create;
    this._select = select;
    this.updateCursor = updateCursor;
    this.finishCasting = finishCasting;
}
Skill.prototype.dom_id = function(unit) {
    return "skill_" + unit.name + "_" + this.name;
}
Skill.prototype.dom = function(unit) {
    /* XXX: memoizeable? */
    return $('#' + this.dom_id(unit));
}
Skill.prototype.selectSkill = function(unit, select) {
    if (select) {
        $('.skillsui').removeClass('skillselected');
        this.dom(unit).addClass('skillselected');
    }
    else {
        this.dom(unit).removeClass('skillselected');
    }
    this._select(unit, select);
    
    /* XXX: pass sceneState instead of accessing global later */
    if (select) {
        sceneState.transition(SceneState.prototype.UI_STATE_TARGET_SKILL, this);
    }
    else {
        sceneState.transition(SceneState.prototype.UI_STATE_SELECTED);
    }
}

let units = [
    new PlayerUnit("Clover",
                   "assets/ferretything.png",
                   "assets/green_target18.png",
                   [
                    new Skill("Entangle",
                              function(scene) {
                                 /* TODO: clean up */
                                 scene.load.image('entangle_target', 'assets/entangle_target_green.png');
                                 scene.load.image('entangle_effect', 'assets/entangle_effect.png');
                              },
                              function(scene) {
                                 let target = scene.add.sprite(0, 0, 'entangle_target');
                                 let effect = scene.add.sprite(0, 0, 'entangle_effect');
                                 
                                 target.visible = false;
                                 effect.visible = false;
                                 
                                 this.cursor_target = target;
                                 this.effect = effect;
                              },
                              function(unit, select) {
                                 this.cursor_target.visible = select;
                              },
                              function(state, unit, ap) {
                                 this.cursor_target.x = ap.position.x;
                                 this.cursor_target.y = ap.position.y;
                              },
                              function(state) {
                                 this.effect.x = this.cursor_target.x;
                                 this.effect.y = this.cursor_target.y;
                                 
                                 this.effect.visible = true;
                                 state.scene.time.addEvent({
                                     delay: 3000,
                                     callback: function () {
                                         this.effect.visible = false;
                                     },
                                     callbackScope: this,
                                 });
                              },
                    ),
                    new Skill("Vine Pull",
                              function(scene) {},
                              function(scene) {},
                              function(unit, select) {},
                              function(state, unit, ap) {},
                              function(state) {},
                    ),
                    new Skill("Leaf Burst",
                              function(scene) {},
                              function(scene) {},
                              function(unit, select) {},
                              function(state, unit, ap) {},
                              function(state) {},
                    ),
                   ]
                  ),
]

var gameOver = false;

var debugScene;
var debugThing;

function preload () {
    this.load.image('sky', 'assets/sky.png');
    this.load.image('ground', 'assets/platform.png');
    this.load.image('star', 'assets/star.png');
    this.load.image(UNIT_SELECTED_IMG, 'assets/pink_cursor.png');
    
    let len = units.length;
    for (let i = 0; i < len; i++) {
        let unit = units[i];
        this.load.spritesheet(unit.name, unit.char_asset_path,
                              {frameWidth: 64, frameHeight: 64});
        this.load.image(unit.move_target_img(), unit.move_target_path);
        
        for (let j in unit.skills) {
            unit.skills[j].preload(this);
        }
    }
}

function create () {
    this.scene_state = sceneState;
    this.scene_state.scene = this;
    
    this.add.image(halfWidth, halfHeight, 'sky');

    let len = units.length;
    for (let i = 0; i < len; i++) {
        let unit = units[i];
        
        let container = this.add.container(0, 0);
        let s = this.add.sprite(0, 0, unit.name);
        let cursor = this.add.sprite(0, 0, UNIT_SELECTED_IMG);
        let move_target = this.add.sprite(0, 0, unit.move_target_img());
        
        // container is the parent
        container.add(s);
        container.add(cursor);
        
        container.x = s.displayWidth / 2;
        container.y = ((i + 1) * s.displayHeight) + (s.displayHeight / 2);
                
        s.setInteractive();
        s.player_unit = units[i];        
        
        cursor.visible = false;
        move_target.visible = false;
                
        unit.container = container;
        unit.sprite = s;
        unit.cursor = cursor;
        unit.move_target = move_target;
        
        for (let j in unit.skills) {
            unit.skills[j].create(this);
        }
        
        // XXX: maybe make this more flexible
        this.anims.create({
            key: "casting",
            frames: [
                {key: unit.name, frame: 4},
                {key: unit.name, frame: 5},
                {key: unit.name, frame: 6},
                {key: unit.name, frame: 5},
                {key: unit.name, frame: 6},
                {key: unit.name, frame: 7},
                {key: unit.name, frame: 0},
            ],
            frameRate: 3,
        });
        
        // XXX: not sure if this is correct, not well documented yet
        let parent = this;
        s.on("animationcomplete",
             function(anim, frame) {
                if (anim.key == "casting") {
                    /*
                     * XXX: would be nice to pass the skill with the event
                     * but seems like globals are the only way
                     */
                    let skill = parent.scene_state.selected_skill;
                                
                    /*
                     * not the clearest, but selectSkill should happen last
                     * since it causes a ui_state transition
                     */
                    skill.finishCasting(parent.scene_state);
                    skill.selectSkill(parent.scene_state.selected_unit, false);
                }
             },
        );
        
        unit.initSkillsUI(this.scene_state);
        
        this.scene_state.units.push(unit);
    }
    
    this.input.on("gameobjectdown", objectClicked);
    
        
    // warning: these are numbers, they become strings if they're object keys
    let codes = [
        Phaser.Input.Keyboard.KeyCodes.ONE,
        Phaser.Input.Keyboard.KeyCodes.TWO,
        Phaser.Input.Keyboard.KeyCodes.THREE,
        Phaser.Input.Keyboard.KeyCodes.FOUR,
        Phaser.Input.Keyboard.KeyCodes.FIVE,
        Phaser.Input.Keyboard.KeyCodes.SIX,
    ];
    for (let i in codes) {
        let key = this.input.keyboard.addKey(codes[i]);
        this.scene_state.skill_keys[codes[i]] = key;
    }
    
    debugScene = this;
}

function objectClicked(ptr, obj) {
    // XXX: not sure on ordering guarantees between this and update    
    let state = this.scene.scene_state;

    if (state.selected_unit !== obj.player_unit) {
        let unit = obj.player_unit;
        
        state.transition(SceneState.prototype.UI_STATE_SELECTED, unit);
        
        unit.cursor.visible = true;
        
        obj.player_unit.showSkillsUI();
    }
      
    // XXX: this seems hella janky, but we don't want a dup event in the update loop
    ptr.justDown = false;
}

function clamp_movement(orig_v, dv, target_v) {
    let new_v = orig_v + dv;
    
    if (dv < 0) {
        if (new_v < target_v) {
            new_v = target_v;
        }
    }
    else {
        if (new_v > target_v) {
            new_v = target_v;
        }
    }
    
    return Math.round(new_v);
}

function steer_units(state) {
    if (state.ui_state === SceneState.prototype.UI_STATE_CASTING) {
        // halt movement while casting
        return;
    }
    
    let len = state.units.length;
    for (let i = 0; i < len; i++) {
        let unit = state.units[i];
        
        if (!unit.has_move_target) {
            continue;
        }
        
        let dx = unit.move_target.x - unit.container.x;
        let dy = unit.move_target.y - unit.container.y;        
        let dist = Math.sqrt((dx * dx) + (dy * dy));
        
        if (dist < Number.EPSILON) {
            unit.has_move_target = false;
            unit.move_target.visible = false;
            continue;
        }
        
        let move_dx = (dx / dist) * unit.move_speed;
        let move_dy = (dy / dist) * unit.move_speed;
        
        // need some logic to not overshoot
        unit.container.x = clamp_movement(unit.container.x,
                                          move_dx,
                                          unit.move_target.x);
        unit.container.y = clamp_movement(unit.container.y,
                                          move_dy,
                                          unit.move_target.y);
    }
}

function keyCodeToSkillNumber(code) {
    // probably want configurable keys later
    switch (parseInt(code, 10)) {
        case Phaser.Input.Keyboard.KeyCodes.ONE:
            return 0;
        case Phaser.Input.Keyboard.KeyCodes.TWO:
            return 1;
        case Phaser.Input.Keyboard.KeyCodes.THREE:
            return 2;
        case Phaser.Input.Keyboard.KeyCodes.FOUR:
            return 3;
        case Phaser.Input.Keyboard.KeyCodes.FIVE:
            return 4;
        case Phaser.Input.Keyboard.KeyCodes.SIX:
            return 5;
    }
    return null;
}

function handleUnitClicks(state, unit, ap) {
    if (state.ui_state === SceneState.prototype.UI_STATE_UNSELECTED) {
        return;
    }
    
    if (!ap.justDown) {
        return;
    }
    
    if (state.ui_state === SceneState.prototype.UI_STATE_TARGET_SKILL) {
        if (ap.leftButtonDown() != 0) {
            let skill_obj = state.selected_skill.dom(unit);
            skill_obj.removeClass('skillselected');
            skill_obj.addClass('skillcasting');
            unit.sprite.anims.play('casting');
            state.transition(SceneState.prototype.UI_STATE_CASTING);
        }
    }
    
    if (ap.rightButtonDown() != 0) {
        if (!unit) {
            console.log(state);
        }
        unit.setMoveTarget(ap.position);
    }
}

function updateUnitCursor(state, unit, ap) {
    if (state.ui_state === SceneState.prototype.UI_STATE_TARGET_SKILL) {
        let skill = state.selected_skill;
        
        /*
         * XXX: probably want to find commonalities so this function can be
         * genericized but for now let them be tightly coupled
         */
        skill.updateCursor(state, unit, ap);
    }
}

function checkUnitKeys(state, unit) {
    if (state.unit_state === SceneState.prototype.UI_STATE_CASTING) {
        return;
    }
    
    for (let code in state.skill_keys) {
        let key = state.skill_keys[code];
        if (!Phaser.Input.Keyboard.JustDown(key)) {
            continue;
        }
        
        let i = keyCodeToSkillNumber(code);
        if (i >= unit.skills.length) {
            continue;
        }
        
        if (state.selected_skill === unit.skills[i]) {
            /* deselect skill */
            let skill = state.selected_skill;
            
            skill.selectSkill(unit, false);
        }
        else {
            let skill = unit.skills[i];
            skill.selectSkill(unit, true);
        }
        break;
    }
}

function update () {
    if (gameOver) {
        return;
    }
    let state = this.scene_state;
    let unit = state.selected_unit;
    
    if (state.ui_state === SceneState.prototype.UI_STATE_UNSELECTED) {
        /* callbacks will handle clicking on player units */
    }
    else {
        let ap = this.input.activePointer;
        
        /* state is somewhat redundant, but unit should always be non-null */
        handleUnitClicks(state, unit, ap);
        checkUnitKeys(state, unit);
        updateUnitCursor(state, unit, ap);
    }
    
    steer_units(state);
}
</script>
<div id="skills" style="visibility: collapse;">
    <div id="skilllisttemplate" style="visibility: collapse;">
        <input type="button" class="skillsui" id="skilltemplate" value="Skill1"
               style="visibility: collapse;">
    </div>
</div>

</body>
</html>